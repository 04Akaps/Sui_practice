import { Provider } from './provider';
import { JsonRpcClient } from '../rpc/client';
import { GatewayTxSeqNumber, GetTxnDigestsResponse, GetObjectDataResponse, SuiObjectInfo, SuiMoveFunctionArgTypes, SuiMoveNormalizedModules, SuiMoveNormalizedModule, SuiMoveNormalizedFunction, SuiMoveNormalizedStruct, TransactionDigest, SuiTransactionResponse, SuiObjectRef, SuiEventFilter, SuiEventEnvelope, SubscriptionId, ExecuteTransactionRequestType, SuiExecuteTransactionResponse, SuiAddress, ObjectOwner, ObjectId, SuiEvents } from '../types';
import { SignatureScheme } from '../cryptography/publickey';
import { WebsocketClient, WebsocketClientOptions } from '../rpc/websocket-client';
export declare class JsonRpcProvider extends Provider {
    endpoint: string;
    skipDataValidation: boolean;
    socketOptions: WebsocketClientOptions;
    protected client: JsonRpcClient;
    protected wsClient: WebsocketClient;
    /**
     * Establish a connection to a Sui RPC endpoint
     *
     * @param endpoint URL to the Sui RPC endpoint
     * @param skipDataValidation default to `false`. If set to `true`, the rpc
     * client will not check if the responses from the RPC server conform to the schema
     * defined in the TypeScript SDK. The mismatches often happen when the SDK
     * is in a different version than the RPC server. Skipping the validation
     * can maximize the version compatibility of the SDK, as not all the schema
     * changes in the RPC response will affect the caller, but the caller needs to
     * understand that the data may not match the TypeSrcript definitions.
     */
    constructor(endpoint: string, skipDataValidation?: boolean, socketOptions?: WebsocketClientOptions);
    getMoveFunctionArgTypes(objectId: string, moduleName: string, functionName: string): Promise<SuiMoveFunctionArgTypes>;
    getNormalizedMoveModulesByPackage(objectId: string): Promise<SuiMoveNormalizedModules>;
    getNormalizedMoveModule(objectId: string, moduleName: string): Promise<SuiMoveNormalizedModule>;
    getNormalizedMoveFunction(objectId: string, moduleName: string, functionName: string): Promise<SuiMoveNormalizedFunction>;
    getNormalizedMoveStruct(objectId: string, moduleName: string, structName: string): Promise<SuiMoveNormalizedStruct>;
    getObjectsOwnedByAddress(address: string): Promise<SuiObjectInfo[]>;
    getGasObjectsOwnedByAddress(address: string): Promise<SuiObjectInfo[]>;
    getObjectsOwnedByObject(objectId: string): Promise<SuiObjectInfo[]>;
    getObject(objectId: string): Promise<GetObjectDataResponse>;
    getObjectRef(objectId: string): Promise<SuiObjectRef | undefined>;
    getObjectBatch(objectIds: string[]): Promise<GetObjectDataResponse[]>;
    getTransactionsForObject(objectID: string): Promise<GetTxnDigestsResponse>;
    getTransactionsForAddress(addressID: string): Promise<GetTxnDigestsResponse>;
    getTransactionWithEffects(digest: TransactionDigest): Promise<SuiTransactionResponse>;
    getTransactionWithEffectsBatch(digests: TransactionDigest[]): Promise<SuiTransactionResponse[]>;
    executeTransaction(txnBytes: string, signatureScheme: SignatureScheme, signature: string, pubkey: string): Promise<SuiTransactionResponse>;
    executeTransactionWithRequestType(txnBytes: string, signatureScheme: SignatureScheme, signature: string, pubkey: string, requestType?: ExecuteTransactionRequestType): Promise<SuiExecuteTransactionResponse>;
    getTotalTransactionNumber(): Promise<number>;
    getTransactionDigestsInRange(start: GatewayTxSeqNumber, end: GatewayTxSeqNumber): Promise<GetTxnDigestsResponse>;
    getRecentTransactions(count: number): Promise<GetTxnDigestsResponse>;
    syncAccountState(address: string): Promise<any>;
    getEventsByTransaction(digest: TransactionDigest, count?: number): Promise<SuiEvents>;
    getEventsByModule(package_: string, module: string, count?: number, startTime?: number, endTime?: number): Promise<SuiEvents>;
    getEventsByMoveEventStructName(moveEventStructName: string, count?: number, startTime?: number, endTime?: number): Promise<SuiEvents>;
    getEventsBySender(sender: SuiAddress, count?: number, startTime?: number, endTime?: number): Promise<SuiEvents>;
    getEventsByRecipient(recipient: ObjectOwner, count?: number, startTime?: number, endTime?: number): Promise<SuiEvents>;
    getEventsByObject(object: ObjectId, count?: number, startTime?: number, endTime?: number): Promise<SuiEvents>;
    getEventsByTimeRange(count?: number, startTime?: number, endTime?: number): Promise<SuiEvents>;
    subscribeEvent(filter: SuiEventFilter, onMessage: (event: SuiEventEnvelope) => void): Promise<SubscriptionId>;
    unsubscribeEvent(id: SubscriptionId): Promise<boolean>;
}
